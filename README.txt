The knapsack algorithm is one of the most common examples of dynamic programming. In the problem, you are given a theoretical knapsack that can hold a certain maximum weight W. You are also given a number of inputs, each of which have a weight and value assigned to it. The goal of the algorithm is to find the maximum value of items that can go in the knapsack without exceeding the weight limit. The Knapsack problem can be classified into many types. This project implements the 0/1 Knapsack problem.

For the correct implementation utilizing a dynamic approach, the first step is to initialize a 2D array to store the optimal value using the first i items with a capacity w. i ranges from o to all n values while w ranges from 0 to W, the given maximum weight. We consider all possible weights of the knapsack and every possible subset of items to produce overlapping subproblems that help us decide if an inclusion is optimal at later stages. For each pairing of weight and items considered, we check if the weight of the current item is less than the capacity w. If not, we donâ€™t include it. If it is less, we use the recurrence relation max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1]. What this represents is checking if the value and remaining weight is greater if the item is included, and if so it is included. If not, it is excluded and the optimal items for that weight and item set remains the same. Once this is run for all weights and items, the array for the actual weight W is looped through to find the items included in the optimal set. Those indices are added to an array which is returned from the function.

For the code, change n and W on lines 53 and 54 and the item weights and values will be auto generated. If you want to input your own values, comment out lines 53-61 and uncomment 40-52 and it will prompt you for inputs for n, W, values, and weights. 